//
//  Executor.swift
//  
//
//  Created by Ratnesh Jain on 07/08/23.
//

import Foundation

public enum Executor {
    struct Contents: Decodable {
        var images: [Image]
    }
    
    struct Image: Decodable {
        var filename: String?
    }
    
    struct Symbols: Decodable {
        var symbols: [Symbol]
    }
    
    struct Symbol: Decodable {
        var filename: String?
    }
    
    // static let appBlue = Color("AppBlue", bundle: .module)
    // Color(uiColor: UIColor(named: "", in: .module)!)
    static var colors = [String]()
    static var images = [String]()
    
    static var generateCode: String = """
    //
    // Generated File!
    //
    // This file is Auto Generated by AssetsGenerator Plugin and should not be edited
    // since it will be replaced by next plugin execution.
    //
    
    import Foundation
    import UIKit
    
    #if SWIFT_PACKAGE
    private let resourceBundle = Foundation.Bundle.module
    #else
    private class ResourceBundleClass {}
    private let resourceBundle = Foundation.Bundle(for: ResourceBundleClass.self)
    #endif
    
    """
    
    static var imageAssetGeneratedCode: String = """
    // MARK: - Image Assets
    public struct ImageAssetResource: Hashable {
        public var name: String
        public var bundle: Bundle
        
        public init(name: String, bundle: Bundle) {
            self.name = name
            self.bundle = bundle
        }
    }
    
    extension ImageResource {
        public init(asset: ImageAssetResource) {
            self.init(name: asset.name, bundle: asset.bundle)
        }
    }
    
    @available(iOS 13.0, *)
    extension UIImage {
        public convenience init(asset: ImageAssetResource) {
            self.init(named: asset.name, in: asset.bundle, with: nil)!
        }
    }
    
    #if canImport(SwiftUI)
    import SwiftUI

    @available(iOS 13.0, *)
    extension Image {
        public init(asset: ImageAssetResource) {
            self.init(asset.name, bundle: asset.bundle)
        }
    }
    #endif
    
    
    """
    
    static var colorAssetGeneratedCode: String = """
    // MARK: - Color Assets
    public struct ColorAssetResource: Hashable {
        public var name: String
        public var bundle: Bundle
        
        public init(name: String, bundle: Bundle) {
            self.name = name
            self.bundle = bundle
        }
    }
    
    extension ColorResource {
        public init(asset: ColorAssetResource) {
            self.init(name: asset.name, bundle: asset.bundle)
        }
    }
    
    @available(iOS 13.0, *)
    extension UIColor {
        public convenience init(asset: ColorAssetResource) {
            self.init(named: asset.name, in: asset.bundle, compatibleWith: nil)!
        }
    }
    
    #if canImport(SwiftUI)
    import SwiftUI

    @available(iOS 13.0, *)
    extension Color {
        public init(asset: ColorAssetResource) {
            self.init(asset.name, bundle: asset.bundle)
        }
    }

    #endif
    
    
    """
    
    public static func run(input: String, output: String) throws {
        let inputURL = URL(fileURLWithPath: input)
        let outputURL = URL(fileURLWithPath: output)
        
        let enumarator = FileManager.default.enumerator(at: inputURL, includingPropertiesForKeys: nil)
        
        while let file = enumarator?.nextObject() as? URL {
            if file.pathExtension == "imageset" {
                try generateImageConstants(input: file)
            }
            if file.pathExtension == "symbolset" {
                try generateSymbolConstants(input: file)
            }
            if file.pathExtension == "colorset" {
                try generateColorConstants(input: file)
            }
        }
        
        if !images.isEmpty {
            generateCode.append(imageAssetGeneratedCode)
            generateCode.append("public extension ImageAssetResource {\n")
            
            for image in images {
                generateCode.append("\t/// The \"\(image)\" asset catalog image resource.\n")
                generateCode.append("\tstatic let \(image.normalisedToVariableName()) = Self.init(name: \"\(image)\", bundle: resourceBundle)\n\n")
            }
            
            generateCode.append("}\n\n")
        }
        
        if !colors.isEmpty {
            generateCode.append(colorAssetGeneratedCode)
            generateCode.append("public extension ColorAssetResource {\n")
            
            for color in colors {
                generateCode.append("\t/// The \"\(color)\" asset catalog color resource.\n")
                generateCode.append("\tstatic let \(color.normalisedToVariableName()) = Self.init(name: \"\(color)\", bundle: resourceBundle)\n\n")
            }
            
            generateCode.append("}\n\n")
        }
        
        try generateCode.write(to: outputURL, atomically: true, encoding: .utf8)
    }
    
    static func generateImageConstants(input: URL) throws {
        let contentJSONURL = input.appendingPathComponent("Contents.json")
        let data = try Data(contentsOf: contentJSONURL)
        let contents = try JSONDecoder().decode(Contents.self, from: data)
        
        let hasImages = contents.images.filter({$0.filename != nil}).isEmpty == false
        
        if hasImages {
            let basename = input.deletingPathExtension().lastPathComponent
            self.images.append(basename)
        }
    }
    
    static func generateSymbolConstants(input: URL) throws {
        let contentJSONURL = input.appendingPathComponent("Contents.json")
        let data = try Data(contentsOf: contentJSONURL)
        let contents = try JSONDecoder().decode(Symbols.self, from: data)
        let hasImages = contents.symbols.filter({$0.filename != nil}).isEmpty == false
        
        if hasImages {
            let basename = input.deletingPathExtension().lastPathComponent
            self.images.append(basename)
        }
    }
    
    static func generateColorConstants(input: URL) throws {
        let basename = input.deletingPathExtension().lastPathComponent
        self.colors.append(basename)
    }
    
}

enum ExecutorError: Error {
    case missingArguments
}

extension String {
    func normalisedToVariableName() -> String {
        guard !self.isEmpty else { return self }
        var copy = self
        if copy.contains(".") {
            copy = copy.split(separator: ".").joined(separator: "_")
        }
        if copy.contains("_") {
            copy = copy.split(separator: "_").map { $0.capitalized }.joined()
        }
        copy.replaceSubrange(...copy.startIndex, with: copy[copy.startIndex].lowercased())
        return copy
    }
}
